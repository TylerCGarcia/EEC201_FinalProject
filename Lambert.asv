[Speaker,Fs] = audioread("Training_Data/s1.wav");
Num_Bank = 20;
Num_of_sample = 256;
M = 100;
Speaker = Speaker/max(Speaker);
numOfFrame = floor((length(Speaker)-Num_of_sample)/100);
mel_scale_spectrum = zeros(floor((length(Speaker)-Num_of_sample)/100),Num_Bank);
mel_banks = melfb(Num_Bank, Num_of_sample, Fs);
mel_banks = full(mel_banks);
mel_scale_ceptrum = zeros(floor((length(Speaker)-Num_of_sample)/100),Num_Bank);
for i = 1:numOfFrame
    frame = Speaker(i*M+1:i*M+Num_of_sample)';
    frameFFT = fft(frame);
    n2 = 1 + floor(Num_of_sample/2);
    z = mel_banks * abs(frameFFT(1:n2)).^2';
    mel_scale_spectrum(i,:) = z;
    for n = 0:Num_Bank-1
        mel_scale_ceptrum(i,n+1) = 0;
        for k = 1:Num_Bank
            mel_scale_ceptrum(i,n+1) = mel_scale_ceptrum(i,n+1) + log(z(k))*cos(n*(k-0.5)*(pi/Num_Bank));
        end 
    end
end
mel_scale_ceptrum1 = mel_scale_ceptrum;
[Speaker,Fs] = audioread("Training_Data/s2.wav");
Num_Bank = 20;
Num_of_sample = 256;
M = 100;
Speaker = Speaker/max(Speaker);
numOfFrame = floor((length(Speaker)-Num_of_sample)/100);
mel_scale_spectrum = zeros(floor((length(Speaker)-Num_of_sample)/100),Num_Bank);
mel_banks = melfb(Num_Bank, Num_of_sample, Fs);
mel_banks = full(mel_banks);
mel_scale_ceptrum = zeros(floor((length(Speaker)-Num_of_sample)/100),Num_Bank);
for i = 1:numOfFrame
    frame = Speaker(i*M+1:i*M+Num_of_sample)';
    frameFFT = fft(frame);
    n2 = 1 + floor(Num_of_sample/2);
    z = mel_banks * abs(frameFFT(1:n2)).^2';
    mel_scale_spectrum(i,:) = z;
    for n = 0:Num_Bank-1
        mel_scale_ceptrum(i,n+1) = 0;
        for k = 1:Num_Bank
            mel_scale_ceptrum(i,n+1) = mel_scale_ceptrum(i,n+1) + log(z(k))*cos(n*(k-0.5)*(pi/Num_Bank));
        end 
    end
end
mel_scale_ceptrum2 = mel_scale_ceptrum;
plot(mel_scale_ceptrum1(:,2),mel_scale_ceptrum1(:,3),'.',mel_scale_ceptrum2(:,2),mel_scale_ceptrum2(:,3),'.')

function b=vqlbg(v,k) 
% VQLBG Vector quantization using the Linde-Buzo-Gray algorithm % 
% Inputs: % v contains training data vectors (one per column)
% k is number of centroids required %
% Outputs: c contains the result VQ codebook (k columns, one for each centroids) 
c=mean(v,2); 
figure(8); 
plot(c(:,:),'.'); 
title('initial codebook'); %pause 
e=0.01;
c(:,1)=c(:,1)+c(:,1)*e;
figure(9); 
plot(c(:,:),'.');
title('codebook1'); %pause 
c(:,2)=c(:,1)-c(:,1)*e 
figure(10);
plot(c(:,:),'.'); 
title('codebook2'); %pause % Nearest Neighbour Searching. 
% Given a current codebook 'c', assign each training vector in 'v' with the
% closest codeword. Using the function disteu2, the distances between these 
% vectors (v and c) are computed. 
d=disteu(v,c); 
[m,id]=min(d,[],2); 
[rows,cols]=size(c); % The centroids of the vectors are found using the mean function. 
for j=1:cols 
    c(:,j)=mean(v(:,find(id==j)),2); 
end 
figure(11); 
plot(c(:,:),'.'); 
title('new cluster'); %pause % for each training vector, find the closest codeword using the min % function. 
n=1;n=n*2;
while cols<16 
    for i=1:cols 
        c(:,i)=c(:,i)+c(:,i)*e; 
        c(:,i+n)=c(:,i)-c(:,i)*e; 
        d=disteu(v,c); [m,i]=min(d,[],2); 
        [rows,cols]=size(c); 
    end 
    figure(12); p
    lot(c(:,:),'.'); 
    title('updated'); %pause % The centroids of the vectors are found using the mean function. 
    for j=1:cols 
        if find(i==j)
            ~isempty(c); 
            c(:,j)=mean(v(:,find(i==j)),2); 
        end 
    end 
    n=n*2; 
end